// This file is part of alsd.
//
// alsd is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// alsd is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with alsd. If not, see <https://www.gnu.org/licenses/>.

//! This is a helper for `acpid` which passes on the netlink events
//! generated by `als_bus`.
#![recursion_limit = "1024"]

extern crate netlink_rust;
extern crate once_cell;
#[macro_use]
extern crate error_chain;
extern crate mio;
extern crate tokio;
extern crate tokio_reactor;
#[macro_use]
extern crate futures;
extern crate nix;

use futures::{Future, Stream};
use netlink_rust::generic::Message as GenlMsg;
use netlink_rust::{Socket, Protocol, Message};
use std::env;
use std::io::{prelude::*, Cursor};
use std::os::unix::net::UnixStream;
use nix::sys::socket::{SockAddr, UnixAddr};

mod nl_tokio;
use self::nl_tokio::AsyncNlSocket;

mod drop_privs;
use self::drop_privs::drop_privs;

mod acpi_nl;
use self::acpi_nl::AcpiEvent;

pub mod errors {
    error_chain! {
        errors {
            GroupNotFound {
                description("Multicast group not found")
            }
            NoSocket {
                description("No socket name given as an argument")
            }
        }
        foreign_links {
            Netlink(netlink_rust::Error);
            IoError(::std::io::Error);
            NixError(::nix::Error);
        }
    }
}
pub use self::errors::*;

fn establish_nl_socket() -> Result<AsyncNlSocket> {
    let mut sock = Socket::new(Protocol::Generic)?;

    let group_id = acpi_nl::ids::mcast_group_id(&mut sock)?;
    sock.multicast_group_subscribe(group_id)?;

    AsyncNlSocket::new(sock)
}

const ACPI_EVENT_IDENTIFIER: u16 = 1;

fn handle_acpi_events<F>(nl_sock: AsyncNlSocket, mut handler: F)
where
    F: FnMut(AcpiEvent) -> Result<()> + Send + 'static,
{
    tokio::run(
        nl_sock
            .for_each(move |msg| {
                if let Message::Data(msg) = msg {
                    let mut msg_data = Cursor::new(msg.data);
                    let genl_msg = GenlMsg::parse(&mut msg_data)?;
                    genl_msg
                        .attributes
                        .iter()
                        .find(|&attr| attr.identifier == ACPI_EVENT_IDENTIFIER)
                        .map(|attr| {
                            let acpi_event: AcpiEvent = attr.as_bytes().into();
                            handler(acpi_event)
                        })
                        .unwrap_or(Ok(()))
                } else {
                    Ok(())
                }
            })
            .map_err(|e| eprintln!("{}", e))
    );
}

fn process_event(event: AcpiEvent, ctl_sock_addr: &SockAddr) -> Result<()> {

    fn connect_ctl_sock(ctl_sock_addr: &SockAddr) -> Result<UnixStream> {
        use nix::sys::socket::*;
        use std::os::unix::io::FromRawFd;

        let ctl_sock_fd = socket(AddressFamily::Unix,
                                 SockType::Stream,
                                 SockFlag::empty(),
                                 None)?;

        connect(ctl_sock_fd, ctl_sock_addr)?;

        unsafe {
            Ok(UnixStream::from_raw_fd(ctl_sock_fd))
        }
    }

    let mut ctl_stream =
        connect_ctl_sock(ctl_sock_addr)?;

    if event.bus_id.as_bytes().starts_with(b"ACPI0008") && event.evt_type == 0x80 {
        write!(ctl_stream, "(UPDATE-SCREEN)")?;
    }

    Ok(())
}

fn main() -> Result<()> {
    let nl_sock = establish_nl_socket()?;

    drop_privs()?;

    let ctl_sock_name: String = env::args().nth(1).ok_or(ErrorKind::NoSocket)?;
    let ctl_sock_addr = SockAddr::Unix(UnixAddr::new_abstract(ctl_sock_name.as_bytes())?);

    handle_acpi_events(nl_sock, move |evt| process_event(evt, &ctl_sock_addr));
    Ok(())
}
